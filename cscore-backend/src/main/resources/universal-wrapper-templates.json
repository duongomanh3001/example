{
  "python_universal": {
    "description": "Universal Python wrapper template for all function patterns",
    "template": "import sys\nimport json\nimport re\n\n{STUDENT_CODE}\n\ndef parse_input_universally(input_line, pattern_type):\n    \"\"\"Universal input parser - template-driven with intelligent pattern detection\"\"\"\n    if not input_line or not input_line.strip():\n        return []\n    \n    input_line = input_line.strip()\n    \n    # Pattern-based parsing with intelligent detection\n    if pattern_type == \"string_char\":\n        # Handle string + character pattern\n        last_space = input_line.rfind(' ')\n        if last_space == -1:\n            return ['', input_line[0] if input_line else ' ']\n        \n        string_part = input_line[:last_space].strip()\n        char_part = input_line[last_space + 1:].strip()\n        \n        # Handle quoted strings\n        if string_part.startswith('\"') and string_part.endswith('\"'):\n            string_part = string_part[1:-1]\n        \n        return [string_part, char_part[0] if char_part else ' ']\n        \n    elif pattern_type == \"array_size\":\n        # Handle array + size pattern\n        numbers_str = input_line.replace(',', ' ').split()\n        numbers = []\n        for x in numbers_str:\n            try:\n                numbers.append(int(x.strip()))\n            except ValueError:\n                continue\n        return [numbers, len(numbers)]\n        \n    elif pattern_type == \"matrix\":\n        # Handle matrix pattern\n        parts = input_line.split()\n        if len(parts) >= 2:\n            try:\n                rows, cols = int(parts[0]), int(parts[1])\n                data = [int(x) for x in parts[2:] if x.isdigit() or x.lstrip('-').isdigit()]\n                matrix = []\n                for i in range(rows):\n                    row = data[i*cols:(i+1)*cols] if (i+1)*cols <= len(data) else []\n                    matrix.append(row)\n                return [matrix, rows, cols]\n            except ValueError:\n                pass\n        return [[], 0, 0]\n        \n    elif pattern_type == \"single_value\":\n        # Handle single value pattern\n        try:\n            return [int(input_line)]\n        except ValueError:\n            try:\n                return [float(input_line)]\n            except ValueError:\n                return [input_line]\n                \n    else:\n        # Default: space-separated multiple values\n        parts = input_line.split()\n        parsed_values = []\n        \n        for part in parts:\n            try:\n                # Try integer first\n                parsed_values.append(int(part))\n            except ValueError:\n                try:\n                    # Try float\n                    parsed_values.append(float(part))\n                except ValueError:\n                    # Keep as string\n                    parsed_values.append(part.strip('\"'))\n        \n        return parsed_values\n\ndef get_default_value(param_type):\n    \"\"\"Get default values for different parameter types\"\"\"\n    defaults = {\n        'string': '',\n        'str': '',\n        'char': ' ',\n        'int': 0,\n        'float': 0.0,\n        'double': 0.0,\n        'array': [],\n        'list': [],\n        'int[][]': [],\n        'matrix': []\n    }\n    return defaults.get(param_type.lower(), None)\n\nif __name__ == \"__main__\":\n    try:\n        input_line = input().strip()\n        pattern_type = \"{PATTERN_TYPE}\"\n        function_name = \"{FUNCTION_NAME}\"\n        expected_types = {EXPECTED_TYPES}\n        \n        # Parse input intelligently based on pattern\n        parsed_args = parse_input_universally(input_line, pattern_type)\n        \n        # Ensure we have the right number of arguments\n        if expected_types and len(parsed_args) < len(expected_types):\n            # Pad with default values\n            while len(parsed_args) < len(expected_types):\n                parsed_args.append(get_default_value(expected_types[len(parsed_args)]))\n        elif expected_types and len(parsed_args) > len(expected_types):\n            # Truncate to expected length\n            parsed_args = parsed_args[:len(expected_types)]\n        \n        # Dynamic function call\n        if function_name and function_name != \"main\" and function_name in globals():\n            if parsed_args:\n                result = globals()[function_name](*parsed_args)\n            else:\n                result = globals()[function_name]()\n                \n            # Handle output intelligently\n            if result is not None:\n                # Format output based on type\n                if isinstance(result, (list, tuple)):\n                    if all(isinstance(x, (list, tuple)) for x in result):\n                        # Matrix output\n                        for row in result:\n                            print(' '.join(map(str, row)))\n                    else:\n                        # Array output\n                        print(' '.join(map(str, result)))\n                else:\n                    # Scalar output\n                    print(result)\n        else:\n            print(f\"Function '{function_name}' not found\")\n            \n    except Exception as e:\n        print(f\"Error: {e}\")\n        import traceback\n        traceback.print_exc()\n        sys.exit(1)\n",
    "patterns": ["string_char", "array_size", "matrix", "single_value", "multiple_values"],
    "languages": ["python"],
    "complexity": "universal"
  },
  
  "c_universal": {
    "description": "Universal C wrapper template for all function patterns",
    "template": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n{STUDENT_CODE}\n\nint main() {\n    char input[2000];\n    char pattern[] = \"{PATTERN_TYPE}\";\n    char function_name[] = \"{FUNCTION_NAME}\";\n    \n    if (!fgets(input, sizeof(input), stdin)) {\n        printf(\"Error reading input\\n\");\n        return 1;\n    }\n    \n    // Remove newline\n    input[strcspn(input, \"\\n\")] = 0;\n    \n    // Basic pattern detection and parsing\n    if (strcmp(pattern, \"string_char\") == 0) {\n        // Parse string and character\n        char *last_space = strrchr(input, ' ');\n        if (last_space) {\n            *last_space = '\\0';\n            char key = *(last_space + 1);\n            char *str = input;\n            \n            // Remove quotes if present\n            if (str[0] == '\"' && str[strlen(str)-1] == '\"') {\n                str[strlen(str)-1] = '\\0';\n                str++;\n            }\n            \n            // Call function (assuming it exists)\n            int result = {FUNCTION_NAME}(str, key);\n            printf(\"%d\", result);\n        }\n    } else if (strcmp(pattern, \"single_value\") == 0) {\n        int value = atoi(input);\n        int result = {FUNCTION_NAME}(value);\n        printf(\"%d\", result);\n    } else {\n        printf(\"Pattern %s not supported in C wrapper\\n\", pattern);\n        return 1;\n    }\n    \n    return 0;\n}\n",
    "patterns": ["string_char", "single_value"],
    "languages": ["c"],
    "complexity": "basic"
  },
  
  "cpp_universal": {
    "description": "Universal C++ wrapper template for all function patterns", 
    "template": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\n{STUDENT_CODE}\n\nint main() {\n    string input_line;\n    string pattern = \"{PATTERN_TYPE}\";\n    string function_name = \"{FUNCTION_NAME}\";\n    \n    if (!getline(cin, input_line)) {\n        cout << \"Error reading input\" << endl;\n        return 1;\n    }\n    \n    // Basic pattern detection and parsing\n    if (pattern == \"string_char\") {\n        // Parse string and character\n        size_t last_space = input_line.find_last_of(' ');\n        if (last_space != string::npos) {\n            string str_part = input_line.substr(0, last_space);\n            char key = input_line[last_space + 1];\n            \n            // Remove quotes if present\n            if (str_part.front() == '\"' && str_part.back() == '\"') {\n                str_part = str_part.substr(1, str_part.length() - 2);\n            }\n            \n            // Call function (assuming it exists)\n            int result = {FUNCTION_NAME}(str_part.c_str(), key);\n            cout << result;\n        }\n    } else if (pattern == \"single_value\") {\n        int value = stoi(input_line);\n        int result = {FUNCTION_NAME}(value);\n        cout << result;\n    } else {\n        cout << \"Pattern \" << pattern << \" not supported in C++ wrapper\" << endl;\n        return 1;\n    }\n    \n    return 0;\n}\n",
    "patterns": ["string_char", "single_value"],
    "languages": ["cpp", "c++"],
    "complexity": "basic"
  },
  
  "java_universal": {
    "description": "Universal Java wrapper template for all function patterns",
    "template": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    \n    {STUDENT_CODE}\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String pattern = \"{PATTERN_TYPE}\";\n        String functionName = \"{FUNCTION_NAME}\";\n        \n        try {\n            if (!scanner.hasNextLine()) {\n                System.out.println(\"Error: No input provided\");\n                System.exit(1);\n            }\n            \n            String inputLine = scanner.nextLine().trim();\n            \n            // Basic pattern detection and parsing\n            if (\"string_char\".equals(pattern)) {\n                // Parse string and character\n                int lastSpace = inputLine.lastIndexOf(' ');\n                if (lastSpace != -1) {\n                    String strPart = inputLine.substring(0, lastSpace).trim();\n                    char key = inputLine.charAt(lastSpace + 1);\n                    \n                    // Remove quotes if present\n                    if (strPart.startsWith(\"\\\"\") && strPart.endsWith(\"\\\"\")) {\n                        strPart = strPart.substring(1, strPart.length() - 1);\n                    }\n                    \n                    // Call function (assuming it exists and is accessible)\n                    // Note: This requires the student function to be static\n                    try {\n                        java.lang.reflect.Method method = Solution.class.getDeclaredMethod(\"{FUNCTION_NAME}\", String.class, char.class);\n                        method.setAccessible(true);\n                        Object result = method.invoke(null, strPart, key);\n                        System.out.println(result);\n                    } catch (Exception e) {\n                        System.out.println(\"Error calling function: \" + e.getMessage());\n                    }\n                }\n            } else if (\"single_value\".equals(pattern)) {\n                int value = Integer.parseInt(inputLine);\n                try {\n                    java.lang.reflect.Method method = Solution.class.getDeclaredMethod(\"{FUNCTION_NAME}\", int.class);\n                    method.setAccessible(true);\n                    Object result = method.invoke(null, value);\n                    System.out.println(result);\n                } catch (Exception e) {\n                    System.out.println(\"Error calling function: \" + e.getMessage());\n                }\n            } else {\n                System.out.println(\"Pattern \" + pattern + \" not supported in Java wrapper\");\n                System.exit(1);\n            }\n            \n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}\n",
    "patterns": ["string_char", "single_value"],
    "languages": ["java"],
    "complexity": "basic"
  }
}